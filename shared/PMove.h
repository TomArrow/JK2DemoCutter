
#ifndef PMOVE_H
#define PMOVE_H
#include "demoCut.h"
#include "CModel.h"
#include <time.h>

#define CLIENTSIDEONLY 1



//anims.h


#define SABER_ANIM_GROUP_SIZE (BOTH_A2_T__B__GENERAL - BOTH_A1_T__B__GENERAL)



// q_shared.c / various


#define SHORT2USHORT(a) ((a)<0 ? ((a)+65535 +1) : (a)) // since q3vm dooesnt like ushort :/
#define USHORT2SHORT(a) ((a)>32767? ((a)-65535 -1) : (a)) // controlled unsigned->signed conversion

typedef enum {
	SENTRY_NOROOM = 1,
	SENTRY_ALREADYPLACED,
	SHIELD_NOROOM,
	SEEKER_ALREADYDEPLOYED
} itemUseFail_t;


#define ATST_HEADSIZE		90
#define ATST_MINS0			-40
#define ATST_MINS1			-40
#define ATST_MINS2			-24
#define ATST_MAXS0			40
#define ATST_MAXS1			40
#define ATST_MAXS2			248

//
// usercmd_t->button bits, many of which are generated by the client system,
// so they aren't game/cgame only definitions
//
#define	BUTTON_ATTACK			1
#define	BUTTON_TALK				2			// displays talk balloon and disables actions
#define	BUTTON_USE_HOLDABLE		4
#define	BUTTON_GESTURE			8
#define	BUTTON_WALKING			16			// walking can't just be infered from MOVE_RUN
										// because a key pressed late in the frame will
										// only generate a small move value for that frame
										// walking will use different animations and
										// won't generate footsteps
#define	BUTTON_USE				32			// the ol' use key returns!
#define BUTTON_FORCEGRIP		64			// 
#define BUTTON_ALT_ATTACK		128

#define	BUTTON_ANY				256			// any key whatsoever

#define BUTTON_FORCEPOWER		512			// use the "active" force power

#define BUTTON_FORCE_LIGHTNING	1024

#define BUTTON_FORCE_DRAIN		2048

#define BUTTON_LASERPOINTER		4096

#define BUTTON_BOUNCEPOWER		8192

#define BUTTON_STRAFEBOT		16384

// Here's an interesting bit.  The bots in TA used buttons to do additional gestures.
// I ripped them out because I didn't want too many buttons given the fact that I was already adding some for JK2.
// We can always add some back in if we want though.
/*
#define BUTTON_AFFIRMATIVE	32
#define	BUTTON_NEGATIVE		64

#define BUTTON_GETFLAG		128
#define BUTTON_GUARDBASE	256
#define BUTTON_PATROL		512
#define BUTTON_FOLLOWME		1024
*/

#define	MOVE_RUN			120			// if forwardmove or rightmove are >= MOVE_RUN,
										// then BUTTON_WALKING should be set



#define PS_PMOVEFRAMECOUNTBITS	6
typedef enum {
	BLK_NO,
	BLK_TIGHT,		// Block only attacks and shots around the saber itself, a bbox of around 12x12x12
	BLK_WIDE		// Block all attacks in an area around the player in a rough arc of 180 degrees
} saberBlockType_t;

typedef enum {
	BLOCKED_NONE,
	BLOCKED_BOUNCE_MOVE,
	BLOCKED_PARRY_BROKEN,
	BLOCKED_ATK_BOUNCE,
	BLOCKED_UPPER_RIGHT,
	BLOCKED_UPPER_LEFT,
	BLOCKED_LOWER_RIGHT,
	BLOCKED_LOWER_LEFT,
	BLOCKED_TOP,
	BLOCKED_UPPER_RIGHT_PROJ,
	BLOCKED_UPPER_LEFT_PROJ,
	BLOCKED_LOWER_RIGHT_PROJ,
	BLOCKED_LOWER_LEFT_PROJ,
	BLOCKED_TOP_PROJ
} saberBlockedType_t;






// bg_defrag_global.h

#define BOUNCEPOWER_MAX 500
#define BOUNCEPOWER_REGEN_MAX 100
#define BOUNCEPOWER_POWERMASK ((1<<9)-1)
#define BOUNCEPOWER_REGENMASK (((1<<7)-1)<<9)

#define CHARGEJUMPFLAG_CHARGING		(1<<0)

#define XYSPEED(a) sqrtf((a)[0]*(a)[0]+(a)[1]*(a)[1])

typedef enum rollStatus_s {
	ROLL_NONE,
	ROLL_STARTED,
	ROLL_AIR,
	ROLL_TOUCH, // temporary ended (touched ground)
	ROLL_ENDED // finalized value
} rollStatus_t;

typedef enum rollType_s {
	ROLLTYPE_FRONT,
	ROLLTYPE_BACK,
	ROLLTYPE_LEFT,
	ROLLTYPE_RIGHT,
} rollType_t;

typedef struct rollState_s {
	rollStatus_t	status;
	qboolean		rollDisqualified;	// if roll is disqualified for the rollympics (touching a teleport, mover or jumppad, or isn't main LB with jk2 movement style, or has more than 1 segment, or has slide)
	qboolean		segmentDisqualified;	// this is if an air segment has a slide. that and following air segments will disqualify the roll from rollympics
	qboolean		rollStartedInAir;
	qboolean		lastFrameWasRoll;	// wwhether we are rolling before pmove
	rollType_t		rollType;
	float			lastSpeed;			// XY velocity before pmove
	int				lastClientSpeed;	// ps->speed before pmove
	int				lastClientTime;		// commandtime before pmove
	int				airClientSpeed;		// last ps->speed before roll ended
	int				finalAirClientSpeed;// last ps->speed before roll ended (of the roll segment that determined speed)
	float			rollSpeed;			// last XY velocity before roll ended
	int				rollAirTime;
	int				rollAirStarted;
	int				lastRollEndedTime;	// last commandtime before roll ended
} rollState_t;

typedef struct raceStyle_s {
	byte movementStyle; // jk2. maybe some day pjk2 => STAT_MOVEMENTSTYLE
	short msec; // -1 if toggle, -2 if float (ignore float for now, its cringe anyway)
	signed char jumpLevel; // 0=no force, -1 = ysal, -2 = ?, 4=jumpcharge?
	short variant; // when we have map variants (invis walls and such). 0 =default (ignore for now)
	short runFlags; // flags from runFlags_t => STAT_RUNFLAGS
} raceStyle_t;



typedef enum //movementstyle enum
{
	//MV_SIEGE,
	MV_JK2,
	MV_PJK2,//MV_BOTJKA,//MV_QW, // dont make bot its own. just make bot a runflag
	MV_JK2SP,//MV_CPM,
	MV_SPEED,//MV_Q3,
	MV_SICKO,//MV_CLIMB,//MV_PJK,
	MV_QUAJK,//MV_WSW,
	MV_BOUNCE,//MV_RJQ3,
	MV_PINBALL,//MV_RJCPM,
	MV_CSS,//MV_SWOOP,
	MV_Q2,//MV_JETPACK,
	MV_FORCE,//MV_SPEED,
	MV_DREAM,//MV_SP,
	MV_CHARGEJUMP,//MV_SLICK,
	//MV_BOTCPM,
	MV_NUMSTYLES
} movementStyle_e;



#define ANTILOOP_MAXYAWCHANGE 270
typedef struct antiLoopState_s {
	float						yawAngleChangeSinceBaseSpeed;
} antiLoopState_t;



//#define a(a,b,c) // not really used, just to avoid compiler getting mad
#define RUNFLAGS(a)\
a(nojumpbug,JUMPBUGDISABLE,0,RUNFLAGSDBPREFIX," /*","*/ ")\
a(nodeadramps,NODEADRAMPS,1,RUNFLAGSDBPREFIX,"","")\
a(nowallstuck,NOWALLSTUCK,2,RUNFLAGSDBPREFIX,"","")\
a(norollstart,NOROLLSTART,3,RUNFLAGSDBPREFIX,"","")\
a(strafebot,BOT,4,RUNFLAGSDBPREFIX,"","")\
a(segmented,SEGMENTED,5,RUNFLAGSDBPREFIX,"","")\
a(norolls,NOROLLS,6,RUNFLAGSDBPREFIX,"","")\
a(tas,TAS,7,RUNFLAGSDBPREFIX,"","")\
a(climb,CLIMBTECH,8,RUNFLAGSDBPREFIX,"","")\
a(jpadcomp,JUMPPADCOMPENSATE,9,RUNFLAGSDBPREFIX,"","")\
a(lavaProtect,LAVAPROTECT,10,RUNFLAGSDBPREFIX,"","")\
a(antiLoop,ANTILOOP,11,RUNFLAGSDBPREFIX,"","")\
//a(wallspawn,WALLSPAWN,9,RUNFLAGSDBPREFIX,"","")

// the "/*","*/" thing for JUMPBUGDISABLE is so we can disable it for query construction (since it doesn't need to be identical to the level's default, we still query both)

#define RUNFLAGSFUNC(a,b,c,d,e,f) RFL_ ## b=1<<c,

typedef enum runFlags_s {
	RUNFLAGS(RUNFLAGSFUNC)
	/*// 0 is vanilla behavior, 1 is deviation
	RFL_JUMPBUGDISABLE = 1 << 0,
	RFL_NODEADRAMPS = 1 << 1,
	//RFL_NOWALLSTUCK = 1<<2, // just fix by now allowing spawn/respawn/teleport to fuck it
	RFL_NOROLLSTART = 1 << 3,
	RFL_BOT = 1 << 4, // allows strafebot
	RFL_SEGMENTED = 1 << 5, // allows respos
	RFL_NOROLLS = 1 << 6,
	//RFL_TAS = 1 << 7, // absolutely everything is allowed. frametime manipulation etc etc
	RFL_CLIMBTECH = 1 << 8 // jka climb techs*/
} runFlags_t;
#undef RUNFLAGSFUNC









// bg_public.h





#define	GAME_VERSION		"basejk-1"

#define	DEFAULT_GRAVITY		800
#define	GIB_HEALTH			-40
#define ARMOR_PROTECTION		0.50 // Shields only stop 50% of armor-piercing dmg
#define ARMOR_REDUCTION_FACTOR	0.50 // Certain damage doesn't take off armor as efficiently

#define	JUMP_VELOCITY		225//270

#define	MAX_ITEMS			256

#define	RANK_TIED_FLAG		0x4000

#define	ITEM_RADIUS			15		// item sizes are needed for client side pickup detection

#define	SCORE_NOT_PRESENT	-9999	// for the CS_SCORES[12] when only one player is present

#define	VOTE_TIME			30000	// 30 seconds before vote times out

#define DEFAULT_MINS_2		-24
#define DEFAULT_MAXS_2		40
#define CROUCH_MAXS_2		16
#define	STANDARD_VIEWHEIGHT_OFFSET -4

#define	MINS_Z				-24
#define	DEFAULT_VIEWHEIGHT	(DEFAULT_MAXS_2+STANDARD_VIEWHEIGHT_OFFSET)//26
#define CROUCH_VIEWHEIGHT	(CROUCH_MAXS_2+STANDARD_VIEWHEIGHT_OFFSET)//12
#define	DEAD_VIEWHEIGHT		-16

#define MAX_CLIENT_SCORE_SEND 20

#define SHIELD_HALFTHICKNESS		4

// mvsdk_svFlags
#define MVSDK_SVFLAG_BBOX                   (1)             // Set by the server in mvsdk_svFlags to signal bbox data in time2
#define MVSDK_SVFLAG_SUBMODEL_WORKAROUND    (1 << 1)        // Set by the server in mvsdk_svFlags to signal that negative submodels are most likely net-overflows and not intentional
#define MVSDK_SVFLAG_SUBMODEL_TIME2         (1 << 2)        // Set by the server in mvsdk_svFlags to signal that a copy of the modelindex is stored in time2 to exceed the 8 bit modelindex limit

// mvsdk_cgFlags
#define MVSDK_CGFLAG_SUBMODEL_WORKAROUND    (1)             // Set by the client in mvsdk_cgFlags to inform the server that it has a workaround for up to 255 submodels (instead of default 127)
#define MVSDK_CGFLAG_SUBMODEL_TIME2         (1 << 1)        // Set by the client in mvsdk_cgFlags to inform the server that it is capable of reading modelindexes >= 255 from time2
#define MVSDK_CGFLAG_SUBMODEL_BYPASS        (1 << 2)        // Set by the client in mvsdk_cgFlags to inform the server that it is capable of loading more than 256 submodels (only set when the engine supports it, too)


#define TTFLAGSSERVERINFO_HASANTILOOPSTATS		(1<<0) 
#define TTFLAGSSERVERINFO_HASFORCESPEEDSMASH	(1<<1) 
#define TTFLAGSSERVERINFO_HASFORCEJUMPCHARGE	(1<<2) 
#define TTFLAGSSERVERINFO_HASCROSSSERVERCHAT	(1<<3) 


#define TTFLAGS_GAMEPLAY_SERVERINFO_MINESWITCHFIX		(1<<0) 


//jk2pro
#define CUSTOMIZERACE_HIDEROLLSPEEDCP			(1<<0)
#define CUSTOMIZERACE_HIDECHECKPOINTCP			(1<<1)
#define CUSTOMIZERACE_HIDEANTILOOPRESTART		(1<<2)
#define CUSTOMIZERACE_HIDEDEFAULTRACESTART		(1<<3)
#define CUSTOMIZERACE_HIDECTFMESSAGESINRRACE	(1<<4)
//#define CUSTOMIZERACE_ANTILOOPAUTORESPAWN	(1<<4)


#define G2_MODEL_PART	50

typedef enum {
	HANDEXTEND_NONE = 0,
	HANDEXTEND_FORCEPUSH,
	HANDEXTEND_FORCEPULL,
	HANDEXTEND_FORCEGRIP,
	HANDEXTEND_SABERPULL,
	HANDEXTEND_CHOKE, //use handextend priorities to choke someone being gripped
	HANDEXTEND_WEAPONREADY,
	HANDEXTEND_DODGE,
	HANDEXTEND_KNOCKDOWN,
	HANDEXTEND_DUELCHALLENGE,
	HANDEXTEND_TAUNT
} forceHandAnims_t;

typedef enum {
	GT_FFA,				// free for all
	GT_HOLOCRON,		// holocron ffa
	GT_JEDIMASTER,		// jedi master
	GT_TOURNAMENT,		// one on one tournament
	GT_SINGLE_PLAYER,	// single player ffa

	//-- team games go after this --

	GT_TEAM,			// team deathmatch
	GT_SAGA,			// saga
	GT_CTF,				// capture the flag
	GT_CTY,
	GT_MAX_GAME_TYPE
} gametype_t;

typedef enum { GENDER_MALE, GENDER_FEMALE, GENDER_NEUTER } gender_t;

//extern vec3_t WP_MuzzlePoint[WP_NUM_WEAPONS_JK2];

extern int forcePowerSorted[NUM_FORCE_POWERS];

/*
===================================================================================

PMOVE MODULE

The pmove code takes a player_state_t and a usercmd_t and generates a new player_state_t
and some other output data.  Used for local prediction on the client game and true
movement on the server game.
===================================================================================
*/




typedef struct animation_s {
	int		firstFrame;
	int		numFrames;
	int		loopFrames;			// 0 to numFrames
	int		frameLerp;			// msec between frames
	int		initialLerp;		// msec to get to first frame
	int		reversed;			// true if animation is reversed
	int		flipflop;			// true if animation should flipflop back to base
} animation_t;

//extern qboolean			BGPAFtextLoaded;
//extern animation_t		bgGlobalAnimations[MAX_TOTALANIMATIONS];
extern animation_t	bgGlobalAnimations[MAX_TOTALANIMATIONS_GENERAL];

// flip the togglebit every time an animation
// changes so a restart of the same anim can be detected
#define	ANIM_TOGGLEBIT		2048		// Maximum number of animation sequences is 2048 (0-2047).  12th bit is the toggle

#define MAX_ANIM_FILES	64

typedef struct
{
	char			filename[MAX_QPATH];
	animation_t		*anims;
//	animsounds_t	torsoAnimSnds[MAX_ANIM_SOUNDS];
//	animsounds_t	legsAnimSnds[MAX_ANIM_SOUNDS];
//	qboolean		soundsCached;
} bgLoadedAnim_t;

extern bgLoadedAnim_t bgAllAnims[MAX_ANIM_FILES];




extern char *forceMasteryLevels[NUM_FORCE_MASTERY_LEVELS];
extern int forceMasteryPoints[NUM_FORCE_MASTERY_LEVELS];

extern int bgForcePowerCost[NUM_FORCE_POWERS][NUM_FORCE_POWER_LEVELS];



//#define TT_FLAG_		(1<<0) //unused

// pmove->pm_flags
#define	PMF_DUCKED			1
#define	PMF_JUMP_HELD		2
#define PMF_ROLLING			4
#define	PMF_BACKWARDS_JUMP	8		// go into backwards land
#define	PMF_BACKWARDS_RUN	16		// coast down to backwards run
#define	PMF_TIME_LAND		32		// pm_time is time before rejump
#define	PMF_TIME_KNOCKBACK	64		// pm_time is an air-accelerate only time
#define	PMF_TIME_WATERJUMP	256		// pm_time is waterjump
#define	PMF_RESPAWNED		512		// clear after attack and jump buttons come up
#define	PMF_USE_ITEM_HELD	1024
#define PMF_UPDATE_ANIM		2048	// UNUSED: The server updated the animation, the pmove should set the ghoul2 anim to match.
#define PMF_FOLLOW			4096	// spectate following another player
#define PMF_SCOREBOARD		8192	// USED ONLY FOR SPECTATORS: spectate as a scoreboard
#define PMF_STUCK_TO_WALL	16384	// grabbing a wall

#define PMF_FJDIDJUMP		2048	// Reusing PMF_UPDATE_ANIM (because unused) for MV_CHARGEJUMP

#define	PMF_ALL_TIMES	(PMF_TIME_WATERJUMP|PMF_TIME_LAND|PMF_TIME_KNOCKBACK)

#define	MAXTOUCH	32

typedef struct bgEntity_s
{
	entityState_t	s;

	//Data type(s) must directly correspond to the head of the gentity and centity structures
//#if defined(__GNUC__) || defined(__GCC__) || defined(MINGW32) || defined(MACOS_X)
//} _bgEntity_t;
//#else
} bgEntity_t;
//#endif

typedef const bgEntity_t* (*getEntFunc_t)(int entNum, void* reference);

typedef enum serverModType_s {
	SVMOD_NONE_UNKNOWN,
	SVMOD_JK2PRO,
	SVMOD_TOMMYTERNAL
}serverModType_t;

typedef struct pmoveModMovement_s {
	int physics;
	int runFlags;
	int msecRestrict;
	qboolean raceMode;
} pmoveModMovement_t;

class PMove;

typedef struct {
	// state (in / out)
	playerState_t	*ps;

	// command (in)
	usercmd_t	cmd;
	usercmd_t	unalteredCmd;
	int			oldButtons;
	int			tracemask;			// collide against these types of surfaces
	int			debugLevel;			// if set, diagnostic output will be printed
	qboolean	noFootsteps;		// if the game is setup for no footsteps by the server
	qboolean	gauntletHit;		// true if a gauntlet attack would actually hit something

	int			framecount;

	// results (out)
	int			numtouch;
	int			touchents[MAXTOUCH];

	int			useEvent;

	vec3_t		mins, maxs;			// bounding box size

	int			watertype;
	int			waterlevel;

	int			gametype;

	int			debugMelee;

	animation_t	*animations;

	float		xyspeed;

	// for fixed msec Pmove
	int			pmove_fixed;
	int			pmove_msec;
	int			pmove_float;

	serverModType_t	mod;

	pmoveModMovement_t modParms;

	// callbacks to test the world
	// these will be different functions during game and cgame
	//void		(PMove::*trace)( trace_t *results, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int passEntityNum, int contentMask );
	//void		(*q2trace)( trace_t *results, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int passEntityNum, int contentMask );
	//int			(PMove::*pointcontents)( const vec3_t point, int passEntityNum );
	int			q2TraceStyle;
	int			q2Skims;

	qboolean	positionChangedOutsidePmove;
#if CLIENTSIDEONLY
	qboolean	haveForceSpeedSmash; // for cgame
#else
	playerState_t* bgClients[MAX_CLIENTS];
#endif
	int			checkDuelLoss;
	int			requiredCmdMsec;
	qboolean	isSpecialPredict; // not a real predict, just for image smoothing

	//rww - bg entitystate access method
#if CLIENTSIDEONLY
	getEntFunc_t	getEnt;
#else
	bgEntity_t* baseEnt; //base address of the entity array (g_entities or cg_entities)
	int			entSize; //size of the struct (gentity_t or centity_t) so things can be dynamic
#endif

	// raw trace that ignores racemode considerations and such. allow us to dbs anyone even in racemode as a meme.
	//void		(*rawtrace)(trace_t* results, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int passEntityNum, int contentMask);

	rollState_t		roll;
	antiLoopState_t antiLoop;
	vec3_t			lastAntiLoopVelocity;

	float			accelMiss;
	float			wishSpeed;
	qboolean		handleStrafebotSlopes;
	int				unlockRandom;
	qboolean		mineSwitchFix;
	qboolean		highFpsFix;
} pmove_t;


#define SETANIM_TORSO 1
#define SETANIM_LEGS  2
#define SETANIM_BOTH  SETANIM_TORSO|SETANIM_LEGS//3

#define SETANIM_FLAG_NORMAL		0//Only set if timer is 0
#define SETANIM_FLAG_OVERRIDE	1//Override previous
#define SETANIM_FLAG_HOLD		2//Set the new timer
#define SETANIM_FLAG_RESTART	4//Allow restarting the anim if playing the same one (weapon fires)
#define SETANIM_FLAG_HOLDLESS	8//Set the new timer


//===================================================================================




// entityState_t->eFlags
#define	EF_DEAD				0x00000001		// don't draw a foe marker over players with EF_DEAD
#define	EF_BOUNCE_SHRAPNEL	0x00000002		// special shrapnel flag
#define	EF_TELEPORT_BIT		0x00000004		// toggled every time the origin abruptly changes

//doesn't do anything
#define	EF_AWARD_EXCELLENT	0x00000008		// draw an excellent sprite

#define EF_PLAYER_EVENT		0x00000010
#define	EF_BOUNCE			0x00000010		// for missiles

#define	EF_BOUNCE_HALF		0x00000020		// for missiles

//doesn't do anything
#define	EF_AWARD_GAUNTLET	0x00000040		// draw a gauntlet sprite

#define	EF_NODRAW			0x00000080		// may have an event, but no model (unspawned items)
#define	EF_FIRING			0x00000100		// for lightning gun
#define EF_ALT_FIRING		0x00000200		// for alt-fires, mostly for lightning guns though
#define	EF_MOVER_STOP		0x00000400		// will push otherwise

//doesn't do anything
#define EF_AWARD_CAP		0x00000800		// draw the capture sprite

#define	EF_TALK				0x00001000		// draw a talk balloon
#define	EF_CONNECTION		0x00002000		// draw a connection trouble sprite
#define	EF_VOTED			0x00004000		// already cast a vote

//next 4 don't actually do anything
#define	EF_AWARD_IMPRESSIVE	0x00008000		// draw an impressive sprite
#define	EF_AWARD_DEFEND		0x00010000		// draw a defend sprite
#define	EF_AWARD_ASSIST		0x00020000		// draw a assist sprite
#define EF_AWARD_DENIED		0x00040000		// denied

#define EF_TEAMVOTED		0x00080000		// already cast a team vote
#define EF_SEEKERDRONE		0x00100000		// show seeker drone floating around head
#define EF_MISSILE_STICK	0x00200000		// missiles that stick to the wall.
#define EF_ITEMPLACEHOLDER	0x00400000		// item effect
#define EF_SOUNDTRACKER		0x00800000		// sound position needs to be updated in relation to another entity
#define EF_DROPPEDWEAPON	0x01000000		// it's a dropped weapon
#define EF_DISINTEGRATION	0x02000000		// being disintegrated by the disruptor
#define EF_INVULNERABLE		0x04000000		// just spawned in or whatever, so is protected
#define EF_SEGMENTEDREPLAY	0x08000000		// is in a segmented replay



typedef enum {
	EFFECT_NONE = 0,
	EFFECT_SMOKE,
	EFFECT_EXPLOSION,
	EFFECT_EXPLOSION_PAS,
	EFFECT_SPARK_EXPLOSION,
	EFFECT_EXPLOSION_TRIPMINE,
	EFFECT_EXPLOSION_DETPACK,
	EFFECT_EXPLOSION_FLECHETTE,
	EFFECT_STUNHIT,
	EFFECT_EXPLOSION_DEMP2ALT,
	EFFECT_MAX
} effectTypes_t;





// Time between location updates
#define TEAM_LOCATION_UPDATE_TIME		1000

// How many players on the overlay
#define TEAM_MAXOVERLAY		32


#define MAX_ITEM_MODELS 4


// These are bit indexes that can be set on uni_clientFlags to disable cheats in the UnityMod client.
// We reuse these for compatibility and to not reinvent the wheel
typedef enum {
	WALLHACK_DISABLE_ITEMS = 0,
	WALLHACK_DISABLE_PLAYERS,
} clientFlags_t;



// included in both the game dll and the client
//extern	gitem_t	bg_itemlist[];
//extern	int		bg_numItems;

float vectoyaw( const vec3_t vec );

gitem_t	*BG_FindItem( const char *classname );
gitem_t	*BG_FindItemForWeapon( weapon_t weapon );
gitem_t	*BG_FindItemForPowerup( powerup_t pw );
gitem_t	*BG_FindItemForHoldable( holdable_t pw );
#define	ITEM_INDEX(x) ((x)-bg_itemlist)

qboolean	BG_CanItemBeGrabbed( int gametype, const entityState_t *ent, const playerState_t *ps, int playerMode);



#define SABER_BLOCK_DUR 150		// number of milliseconds a block animation should take.


#define PLAYERSTATS_PAST_MSEC	4


// g_dmflags->integer flags
#define	DF_NO_FALLING			8
#define DF_FIXED_FOV			16
#define	DF_NO_FOOTSTEPS			32

// content masks
#define	MASK_ALL				(-1)
#define	MASK_SOLID				(CONTENTS_SOLID)
#define	MASK_PLAYERSOLID		(CONTENTS_SOLID|CONTENTS_PLAYERCLIP|CONTENTS_BODY)
#define	MASK_DEADSOLID			(CONTENTS_SOLID|CONTENTS_PLAYERCLIP)
#define	MASK_WATER				(CONTENTS_WATER|CONTENTS_LAVA|CONTENTS_SLIME)
#define	MASK_OPAQUE				(CONTENTS_SOLID|CONTENTS_SLIME|CONTENTS_LAVA)
#define	MASK_SHOT				(CONTENTS_SOLID|CONTENTS_BODY|CONTENTS_CORPSE)


//
// entityState_t->eType
//
typedef enum {
	ET_GENERAL,
	ET_PLAYER,
	ET_ITEM,
	ET_MISSILE,
	ET_SPECIAL,				// rww - force fields
	ET_HOLOCRON,			// rww - holocron icon displays
	ET_MOVER,
	ET_BEAM,
	ET_PORTAL,
	ET_SPEAKER,
	ET_PUSH_TRIGGER,
	ET_TELEPORT_TRIGGER,
	ET_INVISIBLE,
	ET_GRAPPLE,				// grapple hooked on wall
	ET_TEAM,
	ET_BODY,

	ET_EVENTS				// any of the EV_* events can be added freestanding
							// by setting eType to ET_EVENTS + eventNum
							// this avoids having to set eFlags and eventNum
} entityType_t;

// Okay, here lies the much-dreaded Pat-created FSM movement chart...  Heretic II strikes again!
// Why am I inflicting this on you?  Well, it's better than hardcoded states.
// Ideally this will be replaced with an external file or more sophisticated move-picker
// once the game gets out of prototype stage.

// rww - Moved all this to bg_public so that we can access the saberMoveData stuff on the cgame
// which is currently used for determining if a saber trail should be rendered in a given frame
/*
typedef enum {
	LS_INVALID	= -1,
	// Invalid, or saber not armed
	LS_NONE		= 0,

	// General movements with saber
	LS_READY,
	LS_DRAW,
	LS_PUTAWAY,

	// Attacks
	LS_A_TL2BR,//4
	LS_A_L2R,
	LS_A_BL2TR,
	LS_A_BR2TL,
	LS_A_R2L,
	LS_A_TR2BL,
	LS_A_T2B,
	LS_A_BACKSTAB,
	LS_A_BACK,
	LS_A_BACK_CR,
	LS_A_LUNGE,
	LS_A_JUMP_T__B_,
	LS_A_FLIP_STAB,
	LS_A_FLIP_SLASH,

	//starts
	LS_S_TL2BR,//26
	LS_S_L2R,
	LS_S_BL2TR,//# Start of attack chaining to SLASH LR2UL
	LS_S_BR2TL,//# Start of attack chaining to SLASH LR2UL
	LS_S_R2L,
	LS_S_TR2BL,
	LS_S_T2B,

	//returns
	LS_R_TL2BR,//33
	LS_R_L2R,
	LS_R_BL2TR,
	LS_R_BR2TL,
	LS_R_R2L,
	LS_R_TR2BL,
	LS_R_T2B,

	//transitions
	LS_T1_BR__R,//40
	LS_T1_BR_TR,
	LS_T1_BR_T_,
	LS_T1_BR_TL,
	LS_T1_BR__L,
	LS_T1_BR_BL,
	LS_T1__R_BR,//46
	LS_T1__R_TR,
	LS_T1__R_T_,
	LS_T1__R_TL,
	LS_T1__R__L,
	LS_T1__R_BL,
	LS_T1_TR_BR,//52
	LS_T1_TR__R,
	LS_T1_TR_T_,
	LS_T1_TR_TL,
	LS_T1_TR__L,
	LS_T1_TR_BL,
	LS_T1_T__BR,//58
	LS_T1_T___R,
	LS_T1_T__TR,
	LS_T1_T__TL,
	LS_T1_T___L,
	LS_T1_T__BL,
	LS_T1_TL_BR,//64
	LS_T1_TL__R,
	LS_T1_TL_TR,
	LS_T1_TL_T_,
	LS_T1_TL__L,
	LS_T1_TL_BL,
	LS_T1__L_BR,//70
	LS_T1__L__R,
	LS_T1__L_TR,
	LS_T1__L_T_,
	LS_T1__L_TL,
	LS_T1__L_BL,
	LS_T1_BL_BR,//76
	LS_T1_BL__R,
	LS_T1_BL_TR,
	LS_T1_BL_T_,
	LS_T1_BL_TL,
	LS_T1_BL__L,

	//Bounces
	LS_B1_BR,
	LS_B1__R,
	LS_B1_TR,
	LS_B1_T_,
	LS_B1_TL,
	LS_B1__L,
	LS_B1_BL,

	//Deflected attacks
	LS_D1_BR,
	LS_D1__R,
	LS_D1_TR,
	LS_D1_T_,
	LS_D1_TL,
	LS_D1__L,
	LS_D1_BL,
	LS_D1_B_,

	//Reflected attacks
	LS_V1_BR,
	LS_V1__R,
	LS_V1_TR,
	LS_V1_T_,
	LS_V1_TL,
	LS_V1__L,
	LS_V1_BL,
	LS_V1_B_,

	// Broken parries
	LS_H1_T_,//
	LS_H1_TR,
	LS_H1_TL,
	LS_H1_BR,
	LS_H1_B_,
	LS_H1_BL,

	// Knockaways
	LS_K1_T_,//
	LS_K1_TR,
	LS_K1_TL,
	LS_K1_BR,
	LS_K1_BL,

	// Parries
	LS_PARRY_UP,//
	LS_PARRY_UR,
	LS_PARRY_UL,
	LS_PARRY_LR,
	LS_PARRY_LL,

	// Projectile Reflections
	LS_REFLECT_UP,//
	LS_REFLECT_UR,
	LS_REFLECT_UL,
	LS_REFLECT_LR,
	LS_REFLECT_LL,

	LS_MOVE_MAX_DEFAULT,// default max
	LS_JUMPATTACK_ARIAL_LEFT= LS_MOVE_MAX_DEFAULT, // cartwheel from jka
	LS_JUMPATTACK_ARIAL_RIGHT, // cartwheel from jka
	LS_MOVE_MAX
} saberMoveName_t;*/

typedef enum {
	Q_BR,
	Q_R,
	Q_TR,
	Q_T,
	Q_TL,
	Q_L,
	Q_BL,
	Q_B,
	Q_NUM_QUADS
} saberQuadrant_t;




#define ARENAS_PER_TIER		4
#define MAX_ARENAS			4096 // was 1024
#define	MAX_ARENAS_TEXT		16384 // was 8192

#define INFO_HASH_SIZE		1024

//typedef struct infoHashed_s {
//	//short hash;
//	//short arenaNum;
//	char* name;
//	char* info;
//	struct infoHashed_s* next;
//} infoHashed_t;

//extern int					g_numArenas;
//extern infoHashed_t			g_arenaInfosHashed[MAX_ARENAS];

#define MAX_BOTS			1024
#define MAX_BOTS_TEXT		8192


//qboolean BG_DB_VerifyPassword(const char* password, int clientNumNotify);








// bg_local.h





#define	MIN_WALK_NORMAL	0.7f		// can't walk on very steep slopes

#define	STEPSIZE		18

#define	TIMER_LAND		130
#define	TIMER_GESTURE	(34*66+50)

#define	OVERCLIP		1.001f

// all of the locals will be zeroed before each
// pmove, just to make damn sure we don't have
// any differences when running on client or server
typedef struct 
{
	vec3_t		forward, right, up;
	float		frametime;

	int			msec;

	qboolean	walking;
	qboolean	groundPlane;
	trace_t		groundTrace;

	float		impactSpeed;

	vec3_t		previous_origin;
	vec3_t		previous_velocity;
	int			previous_waterlevel;

	int			seed;

	int			randomAdd;

	qboolean	clippedPre;
	qboolean	clipped;
	qboolean	clippedWalkable;
	qboolean	groundBounces;
	qboolean	bounceJumped;
} pml_t;

//extern	pml_t		pml;

// movement parameters
//extern	float	pm_stopspeed;
//extern	float	pm_duckScale;
//extern	float	pm_swimScale;
//extern	float	pm_wadeScale;
//
//extern	float	pm_accelerate;
//extern	float	pm_airaccelerate;
//extern	float	pm_wateraccelerate;
//extern	float	pm_flyaccelerate;
//
//extern	float	pm_friction;
//extern	float	pm_waterfriction;
//extern	float	pm_flightfriction;
//
//extern	int		c_pmove;

extern int forcePowerNeeded_1_02_pm[NUM_FORCE_POWER_LEVELS][NUM_FORCE_POWERS];
extern int forcePowerNeeded_1_04_pm[NUM_FORCE_POWER_LEVELS][NUM_FORCE_POWERS];
extern weaponData_t weaponData_1_02_pm[WP_NUM_WEAPONS_GENERAL];
extern weaponData_t weaponData_1_03_pm[WP_NUM_WEAPONS_GENERAL];
extern weaponData_t weaponData_1_04_pm[WP_NUM_WEAPONS_GENERAL];

typedef enum {
	VERSION_UNDEF = 0,
	VERSION_1_02 = 2,
	VERSION_1_03 = 3,
	VERSION_1_04 = 4,
} mvversion_t;

class PMove {

	bool developer = false;
	mvversion_t	jk2gameplay = VERSION_UNDEF;  // Current gameplay to apply
	pmove_t* pm;
	pml_t		pml;

	CModel* cm = NULL;

	demoType_t	demoType;

	int(*forcePowerNeeded)[NUM_FORCE_POWERS] = NULL;
	weaponData_t* weaponData = NULL;

	qboolean gPMDoSlowFall = qfalse;

	// movement parameters
	float	pm_stopspeed = 100.0f;
	float	pm_duckScale = 0.50f;
	float	pm_swimScale = 0.50f;
	float	pm_wadeScale = 0.70f;

	float	pm_accelerate = 10.0f;
	float	pm_airaccelerate = 1.0f;
	float	pm_wateraccelerate = 4.0f;
	float	pm_flyaccelerate = 8.0f;

	float	pm_friction = 6.0f;
	float	pm_waterfriction = 1.0f;
	float	pm_flightfriction = 3.0f;
	float	pm_spectatorfriction = 5.0f;

	//japro/dfmania movement parameters
	const float pm_vq3_duckScale = 0.25f;
	const float pm_vq3_friction = 8.0f;

	const float	pm_cpm_accelerate = 15.0f;
	const float	pm_cpm_airaccelerate = 1.0f;
	const float	pm_cpm_airstopaccelerate = 2.5f;
	const float	pm_cpm_airstrafeaccelerate = 70.0f;
	const float	pm_cpm_airstrafewishspeed = 30.0f;

	const float	pm_sp_accelerate = 12.0f;
	const float	pm_sp_airaccelerate = 4.0f;
	const float	pm_sp_frictionModifier = 3.0f;	//Used for "careful" mode (when pressing use)
	const float pm_sp_airDecelRate = 1.35f;	//Used for air decelleration away from current movement velocity

	int		c_pmove = 0;

	getEntFunc_t	getEnt;
	void*			getEntReference = NULL;

	inline void	PM_Trace(trace_t* results, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int passEntityNum, int contentMask) {
		if (!cm) {
			throw std::exception("PM_Trace: cm is null.");
			return;
		}

		cm->CM_TraceWrap(results, start, mins, maxs, end, passEntityNum, contentMask);
	}
	inline int	PM_PointContents(vec3_t point, int passEntityNum) {
		if (!cm) {
			throw std::exception("PM_PointContents: cm is null.");
			return 0;
		}

		return cm->CM_PointContentsWrap(point, passEntityNum);
	}

public:
	void SetCModel(CModel* cmodel) {
		cm = cmodel;
	}
	void SetGetEntFunc(getEntFunc_t getEntA) {
		getEnt = getEntA;
	}
	void SetGetEntFuncReference(void* getEntReferenceA) {
		getEntReference = getEntReferenceA;
	}
	PMove(demoType_t demoTypeA, CModel* cmodel, getEntFunc_t getEntA) {
		cm = cmodel;
		getEnt = getEntA;
		demoType = demoTypeA;
		srand(time(NULL));
		switch (demoType)
		{
		case DM_15:
			jk2gameplay = VERSION_1_02;
			weaponData = weaponData_1_02_pm;
			forcePowerNeeded = forcePowerNeeded_1_02_pm;
			jk2gameplay = VERSION_1_02;
			break;
		case DM_15_1_03:
			jk2gameplay = VERSION_1_03;
			weaponData = weaponData_1_03_pm;
			forcePowerNeeded = forcePowerNeeded_1_04_pm;
			jk2gameplay = VERSION_1_03;
			break;
		default:
		case DM_14:
		case DM_16:
			jk2gameplay = VERSION_1_04;
			weaponData = weaponData_1_04_pm;
			forcePowerNeeded = forcePowerNeeded_1_04_pm;
			jk2gameplay = VERSION_1_04;
			break;
		}
		//mysrand(time(NULL)); // On linux rand() behaves different than on Winodws or in a qvm, ...
	}
	void step(playerState_t* ps, usercmd_t* ucmd, void* getEntReferenceA, int gametype) {
		if (getEntReferenceA) {
			getEntReference = getEntReferenceA;
		}
		pmove_t	cg_pmove = { 0 };
		cg_pmove.ps = ps;
		if (cg_pmove.ps->pm_type == PM_DEAD) {
			cg_pmove.tracemask = MASK_PLAYERSOLID & ~CONTENTS_BODY;
		}
		else {
			cg_pmove.tracemask = MASK_PLAYERSOLID;
		}
		if (cg_pmove.ps->persistant[PERS_TEAM] == TEAM_SPECTATOR) {
			cg_pmove.tracemask &= ~CONTENTS_BODY;	// spectators can fly through bodies
		}
		cg_pmove.noFootsteps = qfalse;// (cgs.dmflags & DF_NO_FOOTSTEPS) > 0;
		cg_pmove.haveForceSpeedSmash = qfalse;
		cg_pmove.pmove_fixed = 0;// cg_pmove_fixed.integer;// | cg_pmove_fixed.integer;
		cg_pmove.pmove_msec = 7;// cg_pmove_msec.integer;
		cg_pmove.pmove_float = 0;//cg_pmove_float.integer;

		cg_pmove.debugLevel = 0;
		cg_pmove.isSpecialPredict = qfalse;

		cg_pmove.highFpsFix = qfalse;// (cgs.jcinfo & JK2PRO_CINFO_HIGHFPSFIX);

		cg_pmove.mod = SVMOD_NONE_UNKNOWN;

		cg_pmove.cmd = *ucmd;
		cg_pmove.animations = bgGlobalAnimations;
		cg_pmove.gametype = gametype;
		cg_pmove.debugMelee = 1;
		cg_pmove.unlockRandom = 0;
		cg_pmove.handleStrafebotSlopes = qtrue;
		// bgClients .... sigh

		ps->legsAnim = generalizeGameValue<GMAP_ANIMATIONS, UNSAFE>(ps->legsAnim, demoType);
		ps->torsoAnim = generalizeGameValue<GMAP_ANIMATIONS, UNSAFE>(ps->torsoAnim, demoType);
		ps->saberMove = generalizeGameValue<GMAP_LIGHTSABERMOVE, UNSAFE>(ps->saberMove, demoType);
		ps->weapon = generalizeGameValue<GMAP_WEAPONS, UNSAFE>(ps->weapon, demoType);

		Pmove(&cg_pmove);

		ps->legsAnim = specializeGameValue<GMAP_ANIMATIONS, UNSAFE>(ps->legsAnim, demoType);
		ps->torsoAnim = specializeGameValue<GMAP_ANIMATIONS, UNSAFE>(ps->torsoAnim, demoType);
		ps->saberMove = specializeGameValue<GMAP_LIGHTSABERMOVE, UNSAFE>(ps->saberMove, demoType);
		ps->weapon = specializeGameValue<GMAP_WEAPONS, UNSAFE>(ps->weapon, demoType);

	}
private:


	qboolean BG_InSpecialJump(int anim, int runFlags);
	qboolean BG_InSaberStandAnim(int anim);
	qboolean BG_InReboundJump(int anim);
	qboolean BG_InReboundHold(int anim);
	qboolean BG_InReboundRelease(int anim);
	qboolean BG_InBackFlip(int anim);
	qboolean BG_DirectFlippingAnim(int anim);
	qboolean BG_SaberInAttack(int move);
	qboolean BG_SaberInSpecial(int move);
	qboolean BG_SaberInIdle(int move);
	qboolean BG_FlippingAnim(int anim);
	qboolean BG_SpinningSaberAnim(int anim);
	qboolean BG_SaberInSpecialAttack(int anim);
	int BG_BrokenParryForAttack(int move);
	int BG_BrokenParryForParry(int move, qboolean raceMode);
	int BG_KnockawayForParry(int move);
	qboolean BG_InRoll(playerState_t* ps, int anim);
	qboolean BG_InDeathAnim(int anim);
	int PM_SaberBounceForAttack(int move);
	int PM_SaberDeflectionForQuad(int quad);
	qboolean PM_SaberInDeflect(int move);
	qboolean PM_SaberInParry(int move);
	qboolean PM_SaberInKnockaway(int move);
	qboolean PM_SaberInReflect(int move);
	qboolean PM_SaberInStart(int move);
	qboolean PM_SaberInReturn(int move);
	qboolean PM_InSaberAnim(int anim);
	qboolean PM_InKnockDown(playerState_t* ps);
	qboolean PM_PainAnim(int anim);
	qboolean PM_JumpingAnim(int anim);
	qboolean PM_LandingAnim(int anim);
	qboolean PM_SpinningAnim(int anim);
	qboolean PM_InOnGroundAnim(int anim);
	qboolean PM_InRollComplete(playerState_t * ps, int anim);
	int PM_AnimLength(int index, animNumberGeneral_t anim);
	void PM_ContinueLegsAnim(int anim);
	void PM_ForceLegsAnim(int anim);
	void PM_StartTorsoAnim(int anim);
	void PM_SetLegsAnimTimer(int time);
	void PM_SetTorsoAnimTimer(int time);
	void BG_SaberStartTransAnim(int saberAnimLevel, int anim, float* animSpeed);
	void PM_SetAnimFinal(int setAnimParts, int anim, int setAnimFlags,
		int blendTime);
	void PM_SetAnim(int setAnimParts, int anim, int setAnimFlags, int blendTime);
	int PM_irand_timesync(int val1, int val2, qboolean useDefault, int defaultValue);
	int BG_GetMovePhysics(playerState_t * ps);
	void BG_ForcePowerDrain(playerState_t * ps, forcePowers_t forcePower, int overrideAmt);
	qboolean BG_EnoughForcePowerForMove(int cost);
	saberMoveName_t PM_AttackMoveForQuad(int quad);
	qboolean PM_SaberKataDone(int curmove, int newmove);
	int PM_SaberAnimTransitionAnim(int curmove, int newmove);
	int PM_SaberMoveQuadrantForMovement(usercmd_t * ucmd);
	qboolean PM_SaberInBounce(int move);
	qboolean PM_SaberInTransition(int move);
	int PM_SaberAttackChainAngle(int move1, int move2);
	qboolean PM_SaberKataDone_1_02(void);
	void PM_SetAnimFrame(playerState_t * gent, int frame, qboolean torso, qboolean legs);
#if CLIENTSIDEONLY
	void  PM_SaberLockBreak(const bgEntity_t* genemy, qboolean victory);
#else
	void  PM_SaberLockBreak(playerState_t* genemy, qboolean victory);
#endif
	void PM_SaberLocked(void);
	qboolean PM_SaberInBrokenParry(int move);
	int PM_BrokenParryForParry(int move);
	qboolean PM_CanBackstab(void);
	saberMoveName_t PM_SaberFlipOverAttackMove(trace_t * tr);
	qboolean PM_SomeoneInFront(trace_t * tr);
	saberMoveName_t PM_SaberLungeAttackMove(void);
	saberMoveName_t PM_SaberJumpAttackMove(void);
	float PM_GroundDistance(void);
	saberMoveName_t PM_SaberAttackForMovement(saberMoveName_t curmove);
	void PM_WeaponLightsaber(void);
	void PM_SetSaberMove(short newMove);
	qboolean PM_GroundSlideOkay(float zNormal);
	void PM_LimitedClipVelocity(vec3_t in, vec3_t normal, vec3_t out, float overbounce, float maxSpeed);
	void PM_LimitedClipVelocity2(vec3_t in, vec3_t normal, vec3_t out, float overbounce, float maxSpeedNormal);
	void PM_Q2StepSlideMove_(void);
	void PM_Q2StepSlideMove(qboolean gravity);
	void PM_CheckBounceJump(vec3_t normal, vec3_t velocity);
	qboolean	PM_SlideMove(qboolean gravity);
	qboolean PM_PredictDeadRamp(qboolean gravity);
	void PM_StepSlideMove(qboolean gravity);
	void PM_GrabWallForJump(int anim);
	int PM_GetSaberStance(void);
	qboolean PM_DoSlowFall(void);
	void PM_AddEvent(int newEvent);
	void PM_AddEventWithParm(int newEvent, int parm);
	void PM_AddTouchEnt(int entityNum);
	void PM_ClipVelocityQ2(vec3_t in, vec3_t normal, vec3_t out, float overbounce);
	void PM_ClipVelocity(vec3_t in, vec3_t normal, vec3_t out, float overbounce);
	qboolean PM_ForceJumpingUp(void);
	void PM_JumpForDir(void);
	void PM_SetPMViewAngle(playerState_t * ps, vec3_t angle, usercmd_t * ucmd);
	qboolean PM_AdjustAngleForWallRun(playerState_t * ps, usercmd_t * ucmd, qboolean doMove);
	qboolean PM_AdjustAngleForWallJump(playerState_t * ps, usercmd_t * ucmd, qboolean doMove);
	void PM_SetForceJumpZStart(float value);
	void PM_SetGroundEntityNum(int num);
	qboolean PM_ForcePowerAvailable(forcePowers_t forcePower);
	qboolean PM_ForcePowerUsable(forcePowers_t forcePower);
	int PM_GetVelocityForForceJump(vec3_t jumpVel);
	void PM_Use(void);
	qboolean PM_RunningAnim(int anim);
	void PM_BeginWeaponChange(int weapon);
	void PM_FinishWeaponChange(void);
	int PM_ItemUsable(playerState_t * ps, int forcedUse);
	void PM_UpdateViewAngles(playerState_t * ps, const usercmd_t * cmd);
	void PM_AdjustAttackStates(pmove_t * pm);
	void BG_CmdForRoll(int anim, usercmd_t * pCmd);
	void BG_AdjustClientSpeed(playerState_t * ps, usercmd_t * cmd, int svTime);
	void PM_SetModData(pmove_t * pmove);





	//PM anim utility functions:


	//void BG_CycleInven(playerState_t* ps, int direction);



	
	//BG anim utility functions:
	qboolean PM_CheckJump(void);


	void	BG_AddPredictableEventToPlayerstate( int newEvent, int eventParm, playerState_t *ps );

	void	BG_UserCmdToUserStats(usercmd_t* ucmd, entityState_t* es);
	void	BG_StatsToUserCmd(entityState_t* es, usercmd_t* ucmd);

	void	BG_RaceStyleToUserStats(raceStyle_t* rs, entityState_t* es);
	void	BG_StatsToRaceStyle(entityState_t* es, raceStyle_t* rs);


	void	BG_TouchJumpPad( playerState_t *ps, entityState_t *jumppad, int msecCompensate, int referenceMsec, movementStyle_e style);
	void	BG_TouchJumpPadVelocity(playerState_t* ps, entityState_t* jumppad, int msecCompensate, int referenceMsec, movementStyle_e style);




	qboolean BG_HasYsalamiri(int gametype, playerState_t *ps);
	qboolean BG_CanUseFPNow(int gametype, playerState_t *ps, int time, forcePowers_t power);
	void PM_ChargeForceJump();
	void PM_CheckChargeJump(void);

	void PM_StartLegsAnim(int anim);
	void PM_Friction(void);
	void PM_Accelerate(vec3_t wishdir, float wishspeed, float accel);
	void PM_SickoAccelerate(vec3_t wishdir, float wishspeed, float baseAccel, float maxAccel);
	void PM_QuaJKAccelerate(vec3_t wishdir, float wishspeed, float baseAccel, float maxAccel, float maxAccelWishSpeed);
	void PM_DreamAccelerate(vec3_t wishdir, float wishspeed, float baseAccel, float maxAccel, float maxAccelWishSpeed);
	float PM_CmdScale(usercmd_t* cmd);
	void PM_SetMovementDir(void);
	float BG_ForceWallJumpStrength(void);
	qboolean	PM_CheckWaterJump(void);
	void PM_WaterJumpMove(void);
	void PM_WaterMove(void);
	void PM_FlyMove(void);
	void PM_AirMove(void);
	void PM_WalkMove(void);
	void PM_DeadMove(void);
	void PM_NoclipMove(void);
	int PM_FootstepForSurface(void);
	int PM_TryRoll(void);
	void PM_CrashLand(void);
	int PM_CorrectAllSolid(trace_t* trace);
	void PM_GroundTraceMissed(void);
	void PM_GroundTrace(void);
	void PM_SetWaterLevel(void);
	void PM_CheckDuck(void);
	void PM_Footsteps(void);
	void PM_WaterEvents(void);
	qboolean PM_DoChargedWeapons(void);
	void PM_Weapon(void);
	void PM_Animate(void);
	void PM_DropTimers(void);
	void PM_SetAnimAfterQ2(vec3_t oldVel);
	void PM_CheckRollEnd();
	void PmoveSingle(pmove_t* pmove);
	void Pmove(pmove_t* pmove);
	void PM_ForceJumpCharge();
#if CLIENTSIDEONLY
	const bgEntity_t* PM_BGEntForNum(int num);
#else
	bgEntity_t* PM_BGEntForNum(int num);
#endif
	void PM_UpdateAntiLoop();
};


#endif